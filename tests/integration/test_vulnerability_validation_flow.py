"""
Integration tests for complete vulnerability detection and validation workflows.

Tests the full flow: Detection → Validation → False Positive Filtering → Exploitation
"""

import pytest
import asyncio
from unittest.mock import AsyncMock, Mock, patch
from typing import Dict, Any

from inferno.tools.advanced.ssrf_detector import SSRFDetector
from inferno.tools.advanced.idor_scanner import IDORScanner
from inferno.tools.advanced.validation_engine import ValidationEngine, VulnType
from inferno.tools.advanced.false_positive_filter import FalsePositiveFilter


@pytest.mark.integration
class TestSQLInjectionDetectionFlow:
    """Test complete SQL injection detection and validation flow."""

    @pytest.mark.asyncio
    async def test_sqli_detection_to_validation(self):
        """Test SQLi detection followed by validation."""
        # Mock: Detect SQL injection
        vulnerable_url = "http://testapp.local/search?q=test"

        # Step 1: Initial detection (would use sqlmap or custom detector)
        initial_finding = {
            "url": vulnerable_url,
            "parameter": "q",
            "vuln_type": "sql_injection",
            "payload": "' OR '1'='1",
            "response": "You have an error in your SQL syntax",
            "confidence": 0.7
        }

        # Step 2: Validate with ValidationEngine
        validator = ValidationEngine()

        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.text = "You have an error in your SQL syntax; check the manual"

        with patch.object(validator, '_make_request', return_value=(mock_response, 0.1, "")):
            result = await validator.execute(
                operation="validate",
                url=initial_finding["url"],
                parameter=initial_finding["parameter"],
                vuln_type=initial_finding["vuln_type"],
                original_payload=initial_finding["payload"]
            )

        assert result.success
        assert result.metadata is not None

        # Should confirm SQL injection with high confidence
        assert result.metadata.get("validated") is True
        assert result.metadata.get("confidence") in ["high", "confirmed"]

    @pytest.mark.asyncio
    async def test_sqli_false_positive_filtering(self):
        """Test SQLi false positive filtering for documentation pages."""
        # Mock: False positive from documentation page
        false_positive_finding = {
            "url": "http://testapp.local/docs/sql-tutorial",
            "parameter": "query",
            "vuln_type": "sqli",
            "payload": "' OR '1'='1",
            "response": """
            <html>
            <head><title>Learn SQL - Tutorial</title></head>
            <body>
            <h1>SQL Tutorial</h1>
            <code>SELECT * FROM users WHERE id='1' OR '1'='1'</code>
            <p>This is an example of SQL injection syntax for educational purposes.</p>
            </body>
            </html>
            """,
            "confidence": 0.6
        }

        fp_filter = FalsePositiveFilter()

        result = await fp_filter.execute(
            operation="filter",
            vuln_type=false_positive_finding["vuln_type"],
            url=false_positive_finding["url"],
            payload=false_positive_finding["payload"],
            response=false_positive_finding["response"],
            status_code=200,
            confidence=false_positive_finding["confidence"]
        )

        assert result["success"]
        decision = result["decision"]

        # Should be filtered or marked as likely FP
        assert decision["result"] in ["likely_fp", "filtered"]
        assert not result["should_report"]


@pytest.mark.integration
class TestSSRFDetectionFlow:
    """Test complete SSRF detection and validation flow."""

    @pytest.mark.asyncio
    async def test_ssrf_localhost_detection_and_validation(self):
        """Test SSRF detection with localhost access and validation."""
        detector = SSRFDetector()
        validator = ValidationEngine()

        # Step 1: Detect SSRF
        mock_response = Mock()
        mock_response.status = 200
        mock_response.text = "It works! Apache/2.4.41 (Ubuntu) Server"

        with patch('aiohttp.ClientSession') as mock_session_class:
            mock_session = AsyncMock()
            mock_session_class.return_value.__aenter__.return_value = mock_session

            mock_get = AsyncMock()
            mock_get.__aenter__.return_value = mock_response
            mock_session.get.return_value = mock_get

            result = await detector.execute(
                operation="scan",
                url="http://vulnerable.local/fetch?url=http://safe.com",
                parameter="url",
                test_categories=["localhost"]
            )

        assert result["success"]
        assert result["vulnerability_detected"]

        findings = result["findings"]
        assert len(findings) > 0

        # Verify finding details
        localhost_finding = next(
            (f for f in findings if "localhost" in f["payload"].lower()),
            None
        )
        assert localhost_finding is not None
        assert localhost_finding["ssrf_type"] in ["basic", "partial"]

    @pytest.mark.asyncio
    async def test_ssrf_cloud_metadata_critical_finding(self):
        """Test SSRF detection of cloud metadata access (critical severity)."""
        detector = SSRFDetector()

        # Mock AWS metadata response
        aws_metadata_response = Mock()
        aws_metadata_response.status = 200
        aws_metadata_response.text = '''
        {
            "ami-id": "ami-0abcdef1234567890",
            "instance-id": "i-0123456789abcdef0",
            "instance-type": "t3.medium",
            "security-credentials": {
                "AccessKeyId": "AKIAIOSFODNN7EXAMPLE",
                "SecretAccessKey": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
                "Token": "IQoJb3JpZ2luX2VjEHEaCXVzLWVhc3QtMSJI..."
            }
        }
        '''

        with patch('aiohttp.ClientSession') as mock_session_class:
            mock_session = AsyncMock()
            mock_session_class.return_value.__aenter__.return_value = mock_session

            mock_get = AsyncMock()
            mock_get.__aenter__.return_value = aws_metadata_response
            mock_session.get.return_value = mock_get

            result = await detector.execute(
                operation="test_metadata",
                url="http://vulnerable.local/proxy?target=http://safe.com",
                parameter="target",
                cloud_providers=["aws"]
            )

        assert result["success"]
        assert result["metadata_access"]
        assert result["severity"] == "critical"

        # Verify sensitive data detected
        findings = result["findings"]
        assert len(findings) > 0

        aws_finding = findings[0]
        assert "AccessKeyId" in aws_finding["sensitive_data_found"] or \
               "security-credentials" in aws_finding["sensitive_data_found"]


@pytest.mark.integration
class TestIDORDetectionFlow:
    """Test complete IDOR detection and validation flow."""

    @pytest.mark.asyncio
    async def test_idor_horizontal_privilege_escalation_flow(self):
        """Test IDOR horizontal privilege escalation detection."""
        scanner = IDORScanner()

        # Mock multi-user scenario
        user1_data = '{"user_id": 100, "name": "Alice", "email": "alice@example.com"}'
        user2_data = '{"user_id": 200, "name": "Bob", "email": "bob@example.com"}'

        def mock_request(url, method, context, params=None):
            # Simulate IDOR: User1 can access User2's data
            if "200" in url and context and context.name == "user1":
                response = Mock()
                response.status_code = 200
                response.text = user2_data  # IDOR vulnerability!
                return (response, "")
            elif "100" in url:
                response = Mock()
                response.status_code = 200
                response.text = user1_data
                return (response, "")

            # Default: access denied
            response = Mock()
            response.status_code = 403
            response.text = '{"error": "Forbidden"}'
            return (response, "")

        with patch.object(scanner, '_make_request', side_effect=mock_request):
            result = await scanner.execute(
                operation="scan",
                url="http://api.example.local/users/100/profile",
                method="GET",
                user1_auth={
                    "headers": {"Authorization": "Bearer user1_token"},
                    "user_id": "100"
                },
                user2_auth={
                    "headers": {"Authorization": "Bearer user2_token"},
                    "user_id": "200"
                }
            )

        assert result.success

        # Should detect IDOR
        findings = result.metadata["findings"]
        assert len(findings) > 0

        idor_findings = [f for f in findings if f["type"] == "horizontal"]
        assert len(idor_findings) > 0
        assert idor_findings[0]["severity"] in ["high", "critical"]

    @pytest.mark.asyncio
    async def test_idor_with_false_positive_filter(self):
        """Test IDOR detection with false positive filtering for public data."""
        scanner = IDORScanner()
        fp_filter = FalsePositiveFilter()

        # Public profile data (not really IDOR)
        public_profile_response = '''
        {
            "public_profile": true,
            "username": "johndoe",
            "bio": "Software developer",
            "shared": true,
            "visibility": "public"
        }
        '''

        def mock_request(url, method, context, params=None):
            response = Mock()
            response.status_code = 200
            response.text = public_profile_response
            return (response, "")

        with patch.object(scanner, '_make_request', side_effect=mock_request):
            result = await scanner.execute(
                operation="scan",
                url="http://api.example.local/profiles/123",
                method="GET",
                user1_auth={"headers": {"Authorization": "Bearer token"}}
            )

        # Scanner might flag this as potential IDOR
        if result.metadata["findings_count"] > 0:
            # Apply false positive filter
            finding = {
                "vuln_type": "idor",
                "url": "http://api.example.local/profiles/123",
                "response": public_profile_response,
                "status_code": 200,
                "confidence": 0.6
            }

            filter_result = await fp_filter.execute(
                operation="filter",
                **finding
            )

            # Should recognize public data and reduce confidence
            decision = filter_result["decision"]
            # Public data should result in lower confidence or FP detection
            assert decision["confidence"] < 0.7


@pytest.mark.integration
class TestExploitChainValidation:
    """Test validation of complete exploit chains."""

    @pytest.mark.asyncio
    async def test_sqli_to_auth_bypass_chain(self):
        """Test SQLi leading to authentication bypass chain."""
        # Chain: SQLi → Extract Creds → Login → Admin Access

        chain_steps = []

        # Step 1: SQL Injection detected
        sqli_finding = {
            "vuln_type": "sql_injection",
            "url": "http://testapp.local/search",
            "parameter": "q",
            "payload": "' UNION SELECT username, password FROM users--",
            "extracted_data": {
                "username": "admin",
                "password_hash": "$2y$10$..."
            }
        }
        chain_steps.append(("sqli_detected", sqli_finding))

        # Step 2: Credentials extracted (simulated)
        creds_extracted = {
            "username": "admin",
            "password": "cracked_password"  # Assume hash was cracked
        }
        chain_steps.append(("creds_extracted", creds_extracted))

        # Step 3: Login with extracted credentials
        login_url = "http://testapp.local/login"
        mock_login_response = Mock()
        mock_login_response.status_code = 200
        mock_login_response.text = '{"success": true, "token": "admin_token_123", "role": "admin"}'

        chain_steps.append(("login_success", {"token": "admin_token_123", "role": "admin"}))

        # Step 4: Admin panel access
        admin_url = "http://testapp.local/admin/dashboard"
        mock_admin_response = Mock()
        mock_admin_response.status_code = 200
        mock_admin_response.text = '<html><h1>Admin Dashboard</h1><p>User management</p></html>'

        chain_steps.append(("admin_access", {"url": admin_url, "status": 200}))

        # Validate chain
        assert len(chain_steps) == 4
        assert chain_steps[0][0] == "sqli_detected"
        assert chain_steps[-1][0] == "admin_access"

        # Verify critical path: SQLi → Creds → Auth → Admin
        assert "sqli_detected" in [step[0] for step in chain_steps]
        assert "admin_access" in [step[0] for step in chain_steps]

    @pytest.mark.asyncio
    async def test_ssrf_to_cloud_compromise_chain(self):
        """Test SSRF leading to cloud infrastructure compromise."""
        # Chain: SSRF → Cloud Metadata → AWS Keys → S3 Access

        chain_steps = []

        # Step 1: SSRF detected
        ssrf_finding = {
            "vuln_type": "ssrf",
            "url": "http://webapp.local/proxy",
            "target": "http://169.254.169.254/latest/meta-data/"
        }
        chain_steps.append(("ssrf_detected", ssrf_finding))

        # Step 2: Cloud metadata accessed
        metadata_result = {
            "ami_id": "ami-0123456789",
            "instance_id": "i-0123456789abcdef0",
            "security_credentials_url": "http://169.254.169.254/latest/meta-data/iam/security-credentials/webapp-role"
        }
        chain_steps.append(("metadata_accessed", metadata_result))

        # Step 3: AWS credentials extracted
        aws_creds = {
            "AccessKeyId": "AKIAIOSFODNN7EXAMPLE",
            "SecretAccessKey": "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY",
            "Token": "IQoJb3JpZ2luX2VjEHEaCXVzLWVhc3QtMSJI..."
        }
        chain_steps.append(("aws_creds_extracted", aws_creds))

        # Step 4: S3 bucket access (simulated)
        s3_access = {
            "bucket": "company-data-backup",
            "files_accessed": ["customer-data.csv", "financial-records.xlsx"],
            "sensitive_data_found": True
        }
        chain_steps.append(("s3_compromised", s3_access))

        # Validate chain completeness
        assert len(chain_steps) == 4
        assert chain_steps[0][0] == "ssrf_detected"
        assert chain_steps[-1][0] == "s3_compromised"

        # Verify critical impact
        final_step = chain_steps[-1][1]
        assert final_step["sensitive_data_found"] is True


@pytest.mark.integration
class TestMultiToolCoordination:
    """Test coordination between multiple security tools."""

    @pytest.mark.asyncio
    async def test_reconnaissance_to_exploitation_flow(self):
        """Test full flow: Recon → Detection → Validation → Exploitation."""
        workflow_results = {}

        # Phase 1: Reconnaissance (nmap, directory enumeration)
        recon_results = {
            "open_ports": [80, 443, 22],
            "web_server": "Apache/2.4.41",
            "found_endpoints": [
                "/admin",
                "/api/users",
                "/api/search"
            ]
        }
        workflow_results["recon"] = recon_results

        # Phase 2: Vulnerability Detection
        detection_results = {
            "sqli": {
                "found": True,
                "endpoint": "/api/search",
                "parameter": "q"
            },
            "idor": {
                "found": True,
                "endpoint": "/api/users",
                "parameter": "id"
            }
        }
        workflow_results["detection"] = detection_results

        # Phase 3: Validation
        validator = ValidationEngine()

        # Validate SQL injection
        mock_sqli_response = Mock()
        mock_sqli_response.status_code = 500
        mock_sqli_response.text = "You have an error in your SQL syntax"

        validation_results = {
            "sqli_validated": True,
            "idor_validated": True,
            "confidence": "high"
        }
        workflow_results["validation"] = validation_results

        # Phase 4: Exploitation (simulated)
        exploitation_results = {
            "sqli_exploited": True,
            "data_extracted": ["admin:hashed_password", "user1:hashed_password"],
            "impact": "critical"
        }
        workflow_results["exploitation"] = exploitation_results

        # Verify complete workflow
        assert "recon" in workflow_results
        assert "detection" in workflow_results
        assert "validation" in workflow_results
        assert "exploitation" in workflow_results

        # Verify impact assessment
        assert workflow_results["exploitation"]["impact"] == "critical"


@pytest.mark.integration
class TestRateLimitingAndNetworkCoordination:
    """Test rate limiting and network coordination across tools."""

    @pytest.mark.asyncio
    async def test_concurrent_scanning_with_rate_limiting(self):
        """Test that concurrent scans respect rate limits."""
        scanner = IDORScanner()

        # Simulate rate-limited endpoint
        request_timestamps = []

        def mock_request(url, method, context, params=None):
            import time
            request_timestamps.append(time.time())

            # Simulate rate limit: 403 if too many requests
            if len(request_timestamps) >= 2:
                time_diff = request_timestamps[-1] - request_timestamps[-2]
                if time_diff < 0.1:  # Less than 100ms between requests
                    response = Mock()
                    response.status_code = 429
                    response.text = '{"error": "Rate limit exceeded"}'
                    return (response, "")

            response = Mock()
            response.status_code = 200
            response.text = '{"data": "ok"}'
            return (response, "")

        with patch.object(scanner, '_make_request', side_effect=mock_request):
            # Scan multiple IDs
            result = await scanner.execute(
                operation="enum",
                url="http://api.example.local/users/{id}",
                method="GET",
                enum_start=1,
                enum_count=5,
                user1_auth={"headers": {"Authorization": "Bearer token"}}
            )

        # Should handle rate limiting gracefully
        assert result.success

        # Verify requests were spaced out (asyncio.sleep in enum operation)
        if len(request_timestamps) >= 2:
            # Check that there was some delay between requests
            time_diffs = [
                request_timestamps[i] - request_timestamps[i-1]
                for i in range(1, len(request_timestamps))
            ]
            # At least some requests should have delay >= 0.05s (from asyncio.sleep(0.05))
            assert any(diff >= 0.045 for diff in time_diffs)


@pytest.mark.integration
class TestErrorRecoveryAndRetry:
    """Test error recovery and retry logic in vulnerability detection."""

    @pytest.mark.asyncio
    async def test_retry_on_timeout(self):
        """Test retry logic when requests timeout."""
        scanner = IDORScanner()

        call_count = [0]

        def mock_request(url, method, context, params=None):
            call_count[0] += 1

            # First call: timeout
            if call_count[0] == 1:
                return (None, "Connection timeout")

            # Second call: success
            response = Mock()
            response.status_code = 200
            response.text = '{"data": "success"}'
            return (response, "")

        with patch.object(scanner, '_make_request', side_effect=mock_request):
            result = await scanner.execute(
                operation="scan",
                url="http://api.example.local/users/123",
                method="GET",
                user1_auth={"headers": {"Authorization": "Bearer token"}}
            )

        # Should handle timeout gracefully
        assert result.success

    @pytest.mark.asyncio
    async def test_graceful_degradation_on_network_errors(self):
        """Test graceful degradation when network errors occur."""
        validator = ValidationEngine()

        def mock_request(url, method, params, headers, cookies):
            # Simulate network error
            return (None, 0, "Connection reset by peer")

        with patch.object(validator, '_make_request', side_effect=mock_request):
            result = await validator.execute(
                operation="validate",
                url="http://unreachable.local/api",
                parameter="q",
                vuln_type="sql_injection",
                original_payload="' OR '1'='1"
            )

        # Should return result (even if validation failed due to network)
        assert isinstance(result, object)  # ToolResult object
