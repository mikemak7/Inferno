"""
Bug bounty platform export formats.

Supports:
- HackerOne report format
- Bugcrowd submission format
- SARIF for CI/CD integration
- GitHub Security Advisory format
"""

from __future__ import annotations

import json
from datetime import datetime, timezone
from typing import Any

import structlog

from inferno.reporting.models import Finding, Report, Severity

logger = structlog.get_logger(__name__)


# CVSS 3.1 severity mapping
CVSS_SEVERITY_MAP = {
    Severity.CRITICAL: (9.0, 10.0),
    Severity.HIGH: (7.0, 8.9),
    Severity.MEDIUM: (4.0, 6.9),
    Severity.LOW: (0.1, 3.9),
    Severity.INFO: (0.0, 0.0),
}

# CWE mapping by vulnerability type keywords
CWE_MAPPINGS = {
    "sql injection": ["CWE-89"],
    "sqli": ["CWE-89"],
    "xss": ["CWE-79"],
    "cross-site scripting": ["CWE-79"],
    "csrf": ["CWE-352"],
    "ssrf": ["CWE-918"],
    "server-side request forgery": ["CWE-918"],
    "idor": ["CWE-639"],
    "insecure direct object reference": ["CWE-639"],
    "path traversal": ["CWE-22"],
    "directory traversal": ["CWE-22"],
    "lfi": ["CWE-98"],
    "local file inclusion": ["CWE-98"],
    "rfi": ["CWE-98"],
    "remote file inclusion": ["CWE-98"],
    "command injection": ["CWE-78"],
    "os command injection": ["CWE-78"],
    "rce": ["CWE-94"],
    "remote code execution": ["CWE-94"],
    "ssti": ["CWE-94"],
    "template injection": ["CWE-94"],
    "xxe": ["CWE-611"],
    "xml external entity": ["CWE-611"],
    "authentication bypass": ["CWE-287"],
    "auth bypass": ["CWE-287"],
    "broken authentication": ["CWE-287"],
    "information disclosure": ["CWE-200"],
    "sensitive data exposure": ["CWE-200"],
    "open redirect": ["CWE-601"],
    "deserialization": ["CWE-502"],
    "insecure deserialization": ["CWE-502"],
}


class BugBountyExporter:
    """Export findings to bug bounty platform formats."""

    def __init__(self) -> None:
        pass

    def export_hackerone(self, finding: Finding) -> str:
        """
        Generate HackerOne-formatted report for a finding.

        Format follows HackerOne's recommended structure:
        - Title
        - Summary
        - Severity justification
        - Steps to reproduce
        - Impact
        - Remediation
        - Proof of concept
        """
        cwe_ids = self._infer_cwe_ids(finding)
        cvss_estimate = self._estimate_cvss(finding)

        report = f"""# {finding.title}

## Summary
{self._generate_summary(finding)}

## Severity
**{finding.severity.value.upper()}** ({cvss_estimate:.1f} CVSS estimated)

{self._generate_severity_justification(finding)}

## Vulnerability Type
{self._get_vulnerability_type(finding)}
{f"CWE: {', '.join(cwe_ids)}" if cwe_ids else ""}

## Steps to Reproduce
{self._format_reproduction_steps(finding)}

## Impact
{self._generate_impact_statement(finding)}

## Proof of Concept
```
{finding.proof_of_concept or "See steps to reproduce above"}
```

## Supporting Evidence
{finding.evidence or "N/A"}

## Affected Asset
{finding.affected_asset}

## Remediation
{finding.remediation or self._suggest_remediation(finding)}

---
*Report generated by Inferno AI - {datetime.now(timezone.utc).isoformat()}*
"""
        return report

    def export_bugcrowd(self, finding: Finding) -> dict[str, Any]:
        """
        Generate Bugcrowd API submission payload.

        Returns dict suitable for Bugcrowd API submission.
        """
        cwe_ids = self._infer_cwe_ids(finding)

        return {
            "title": finding.title,
            "description": self._generate_summary(finding),
            "vulnerability_type": self._get_vrt_id(finding),
            "severity": self._map_severity_to_bugcrowd(finding.severity),
            "proof_of_concept": finding.proof_of_concept or "",
            "steps_to_reproduce": self._format_reproduction_steps(finding),
            "impact": self._generate_impact_statement(finding),
            "remediation": finding.remediation or self._suggest_remediation(finding),
            "affected_asset": finding.affected_asset,
            "cwe_ids": cwe_ids,
            "metadata": {
                "risk_score": finding.metadata.get("risk_score", 50),
                "confidence": finding.metadata.get("confidence", 0.8),
                "generated_at": datetime.now(timezone.utc).isoformat(),
                "generator": "inferno-ai",
            },
        }

    def export_sarif(self, report: Report) -> dict[str, Any]:
        """
        Generate SARIF (Static Analysis Results Interchange Format).

        For CI/CD integration and GitHub Code Scanning.
        """
        results = []
        rules = []
        rule_ids_seen = set()

        for finding in report.findings:
            rule_id = self._generate_rule_id(finding)

            # Add rule definition if not seen
            if rule_id not in rule_ids_seen:
                rule_ids_seen.add(rule_id)
                rules.append({
                    "id": rule_id,
                    "name": self._get_vulnerability_type(finding),
                    "shortDescription": {
                        "text": finding.title,
                    },
                    "fullDescription": {
                        "text": finding.description,
                    },
                    "defaultConfiguration": {
                        "level": self._severity_to_sarif_level(finding.severity),
                    },
                    "properties": {
                        "security-severity": str(self._estimate_cvss(finding)),
                    },
                })

            # Add result
            results.append({
                "ruleId": rule_id,
                "level": self._severity_to_sarif_level(finding.severity),
                "message": {
                    "text": finding.description,
                },
                "locations": [{
                    "physicalLocation": {
                        "artifactLocation": {
                            "uri": finding.affected_asset,
                        },
                    },
                }],
                "properties": {
                    "risk_score": finding.metadata.get("risk_score", 50),
                    "confidence": finding.metadata.get("confidence", 0.8),
                    "proof_of_concept": finding.proof_of_concept,
                },
            })

        return {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [{
                "tool": {
                    "driver": {
                        "name": "Inferno AI",
                        "version": "1.0.0",
                        "informationUri": "https://github.com/inferno-ai/inferno",
                        "rules": rules,
                    },
                },
                "results": results,
                "invocations": [{
                    "executionSuccessful": True,
                    "endTimeUtc": datetime.now(timezone.utc).isoformat(),
                }],
            }],
        }

    def export_github_advisory(self, finding: Finding) -> dict[str, Any]:
        """
        Generate GitHub Security Advisory format.

        For private vulnerability reporting via GitHub.
        """
        cwe_ids = self._infer_cwe_ids(finding)
        cvss_estimate = self._estimate_cvss(finding)

        return {
            "summary": finding.title,
            "description": self._generate_summary(finding),
            "severity": finding.severity.value.lower(),
            "cvss_vector_string": self._generate_cvss_vector(finding),
            "cwe_ids": cwe_ids,
            "vulnerabilities": [{
                "package": {
                    "ecosystem": "URL",
                    "name": finding.affected_asset,
                },
                "vulnerable_version_range": "*",
                "patched_versions": None,
            }],
            "credits": [{
                "login": "inferno-ai",
                "type": "tool",
            }],
        }

    def export_markdown_summary(self, report: Report) -> str:
        """Generate a markdown summary of all findings."""
        lines = [
            f"# Security Assessment Report",
            f"",
            f"**Target:** {report.metadata.target}",
            f"**Date:** {report.metadata.started_at.strftime('%Y-%m-%d %H:%M UTC')}",
            f"**Duration:** {report.metadata.duration_seconds}s",
            f"",
            f"## Summary",
            f"",
            f"| Severity | Count |",
            f"|----------|-------|",
        ]

        # Count by severity
        severity_counts: dict[str, int] = {}
        for finding in report.findings:
            sev = finding.severity.value
            severity_counts[sev] = severity_counts.get(sev, 0) + 1

        for sev in ["critical", "high", "medium", "low", "info"]:
            count = severity_counts.get(sev, 0)
            if count > 0:
                lines.append(f"| {sev.upper()} | {count} |")

        lines.extend([
            f"",
            f"**Total Findings:** {len(report.findings)}",
            f"",
            f"## Findings",
            f"",
        ])

        for i, finding in enumerate(report.findings, 1):
            icon = self._severity_icon(finding.severity)
            lines.extend([
                f"### {i}. {icon} {finding.title}",
                f"",
                f"**Severity:** {finding.severity.value.upper()}",
                f"**Asset:** {finding.affected_asset}",
                f"**Risk Score:** {finding.metadata.get('risk_score', 50)}/100",
                f"",
                f"{finding.description[:500]}{'...' if len(finding.description) > 500 else ''}",
                f"",
            ])

        return "\n".join(lines)

    # Helper methods

    def _generate_summary(self, finding: Finding) -> str:
        """Generate executive summary for a finding."""
        return f"""A {finding.severity.value} severity {self._get_vulnerability_type(finding)} vulnerability was identified in {finding.affected_asset}.

{finding.description}

This vulnerability could allow an attacker to {self._get_attack_outcome(finding)}."""

    def _generate_severity_justification(self, finding: Finding) -> str:
        """Justify the severity rating."""
        justifications = {
            Severity.CRITICAL: "This vulnerability allows immediate compromise with no user interaction required. Full system access or sensitive data exposure is possible.",
            Severity.HIGH: "This vulnerability has significant impact and is relatively easy to exploit. It could lead to substantial data exposure or system compromise.",
            Severity.MEDIUM: "This vulnerability requires specific conditions to exploit but could lead to moderate impact if successful.",
            Severity.LOW: "This vulnerability has limited impact or requires significant prerequisites to exploit.",
            Severity.INFO: "This is an informational finding that may indicate a potential security concern but does not represent an immediate risk.",
        }
        return justifications.get(finding.severity, "Severity assessed based on potential impact and exploitability.")

    def _format_reproduction_steps(self, finding: Finding) -> str:
        """Format reproduction steps from finding data."""
        if finding.proof_of_concept:
            lines = finding.proof_of_concept.split("\n")
            steps = []
            for i, line in enumerate(lines, 1):
                if line.strip():
                    steps.append(f"{i}. {line.strip()}")
            if steps:
                return "\n".join(steps)

        # Generate generic steps
        return f"""1. Navigate to {finding.affected_asset}
2. Identify the vulnerable parameter/endpoint
3. Submit the payload as described in the PoC section
4. Observe the vulnerability behavior in the response"""

    def _generate_impact_statement(self, finding: Finding) -> str:
        """Generate business impact statement."""
        vuln_type = self._get_vulnerability_type(finding).lower()

        impact_templates = {
            "sql injection": "An attacker could extract sensitive data from the database, modify or delete records, or potentially gain shell access to the underlying server.",
            "xss": "An attacker could steal user session cookies, redirect users to malicious sites, or perform actions on behalf of authenticated users.",
            "ssrf": "An attacker could access internal services, scan internal networks, or potentially read sensitive files from cloud metadata endpoints.",
            "idor": "An attacker could access or modify data belonging to other users, potentially leading to unauthorized data disclosure or account takeover.",
            "rce": "An attacker could execute arbitrary commands on the server, leading to complete system compromise.",
            "authentication bypass": "An attacker could gain unauthorized access to protected resources or user accounts without valid credentials.",
        }

        for key, impact in impact_templates.items():
            if key in vuln_type:
                return impact

        return f"Successful exploitation could compromise the {finding.severity.value} integrity of the affected system and potentially impact confidentiality and availability."

    def _suggest_remediation(self, finding: Finding) -> str:
        """Suggest remediation based on vulnerability type."""
        vuln_type = self._get_vulnerability_type(finding).lower()

        remediations = {
            "sql injection": "Use parameterized queries or prepared statements. Implement input validation and escape special characters.",
            "xss": "Implement proper output encoding. Use Content-Security-Policy headers. Validate and sanitize all user input.",
            "ssrf": "Implement URL allowlisting. Disable unnecessary URL schemes. Use network segmentation to limit internal access.",
            "idor": "Implement proper authorization checks. Use indirect object references. Verify user permissions for each request.",
            "rce": "Avoid using user input in system commands. Implement strict input validation. Use application sandboxing.",
            "csrf": "Implement anti-CSRF tokens. Verify Origin/Referer headers. Use SameSite cookie attribute.",
        }

        for key, remediation in remediations.items():
            if key in vuln_type:
                return remediation

        return "Review the vulnerable code and implement appropriate security controls. Follow OWASP guidelines for secure development."

    def _infer_cwe_ids(self, finding: Finding) -> list[str]:
        """Infer CWE IDs from finding description."""
        text = f"{finding.title} {finding.description}".lower()
        cwe_ids = []

        for keyword, cwes in CWE_MAPPINGS.items():
            if keyword in text:
                cwe_ids.extend(cwes)

        return list(set(cwe_ids))

    def _estimate_cvss(self, finding: Finding) -> float:
        """Estimate CVSS score from severity."""
        ranges = CVSS_SEVERITY_MAP.get(finding.severity, (5.0, 5.0))
        # Use risk_score to interpolate within range
        normalized_risk = finding.metadata.get("risk_score", 50) / 100.0
        return ranges[0] + (ranges[1] - ranges[0]) * normalized_risk

    def _generate_cvss_vector(self, finding: Finding) -> str:
        """Generate approximate CVSS 3.1 vector string."""
        # Simplified vector based on severity
        vectors = {
            Severity.CRITICAL: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H",
            Severity.HIGH: "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
            Severity.MEDIUM: "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:N",
            Severity.LOW: "CVSS:3.1/AV:N/AC:H/PR:L/UI:R/S:U/C:L/I:N/A:N",
            Severity.INFO: "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:N/A:N",
        }
        return vectors.get(finding.severity, "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N")

    def _get_vulnerability_type(self, finding: Finding) -> str:
        """Extract vulnerability type from finding."""
        text = f"{finding.title} {finding.description}".lower()

        type_mappings = [
            ("sql injection", "SQL Injection"),
            ("sqli", "SQL Injection"),
            ("xss", "Cross-Site Scripting (XSS)"),
            ("cross-site scripting", "Cross-Site Scripting (XSS)"),
            ("ssrf", "Server-Side Request Forgery (SSRF)"),
            ("idor", "Insecure Direct Object Reference (IDOR)"),
            ("csrf", "Cross-Site Request Forgery (CSRF)"),
            ("rce", "Remote Code Execution (RCE)"),
            ("command injection", "Command Injection"),
            ("path traversal", "Path Traversal"),
            ("lfi", "Local File Inclusion (LFI)"),
            ("xxe", "XML External Entity (XXE)"),
            ("ssti", "Server-Side Template Injection (SSTI)"),
            ("authentication bypass", "Authentication Bypass"),
            ("open redirect", "Open Redirect"),
        ]

        for keyword, vuln_type in type_mappings:
            if keyword in text:
                return vuln_type

        return "Security Vulnerability"

    def _get_vrt_id(self, finding: Finding) -> str:
        """Get Bugcrowd VRT (Vulnerability Rating Taxonomy) ID."""
        vuln_type = self._get_vulnerability_type(finding).lower()

        vrt_mappings = {
            "sql injection": "server_side_injection.sql_injection",
            "xss": "cross_site_scripting_xss.reflected",
            "ssrf": "server_side_injection.ssrf",
            "idor": "broken_access_control.idor",
            "csrf": "cross_site_request_forgery",
            "rce": "server_side_injection.remote_code_execution",
            "command injection": "server_side_injection.command_injection",
            "path traversal": "server_side_injection.path_traversal",
            "lfi": "server_side_injection.file_inclusion.local",
            "xxe": "server_side_injection.xxe",
            "ssti": "server_side_injection.template_injection",
            "authentication bypass": "broken_authentication",
            "open redirect": "unvalidated_redirects_and_forwards.open_redirect",
        }

        for keyword, vrt_id in vrt_mappings.items():
            if keyword in vuln_type:
                return vrt_id

        return "other"

    def _map_severity_to_bugcrowd(self, severity: Severity) -> int:
        """Map severity to Bugcrowd's 1-5 scale."""
        mapping = {
            Severity.CRITICAL: 5,
            Severity.HIGH: 4,
            Severity.MEDIUM: 3,
            Severity.LOW: 2,
            Severity.INFO: 1,
        }
        return mapping.get(severity, 3)

    def _severity_to_sarif_level(self, severity: Severity) -> str:
        """Map severity to SARIF level."""
        mapping = {
            Severity.CRITICAL: "error",
            Severity.HIGH: "error",
            Severity.MEDIUM: "warning",
            Severity.LOW: "note",
            Severity.INFO: "none",
        }
        return mapping.get(severity, "warning")

    def _generate_rule_id(self, finding: Finding) -> str:
        """Generate a rule ID for SARIF."""
        vuln_type = self._get_vulnerability_type(finding)
        return vuln_type.lower().replace(" ", "_").replace("(", "").replace(")", "")

    def _get_attack_outcome(self, finding: Finding) -> str:
        """Get potential attack outcome description."""
        vuln_type = self._get_vulnerability_type(finding).lower()

        outcomes = {
            "sql injection": "extract, modify, or delete sensitive data from the database",
            "xss": "steal user credentials, hijack sessions, or perform actions as the victim",
            "ssrf": "access internal services, read sensitive files, or pivot to internal networks",
            "idor": "access or modify data belonging to other users",
            "rce": "execute arbitrary code and fully compromise the server",
            "csrf": "perform unauthorized actions on behalf of authenticated users",
            "authentication bypass": "gain unauthorized access to protected resources",
        }

        for keyword, outcome in outcomes.items():
            if keyword in vuln_type:
                return outcome

        return "compromise the security of the application"

    def _severity_icon(self, severity: Severity) -> str:
        """Get icon for severity level."""
        icons = {
            Severity.CRITICAL: "[CRITICAL]",
            Severity.HIGH: "[HIGH]",
            Severity.MEDIUM: "[MEDIUM]",
            Severity.LOW: "[LOW]",
            Severity.INFO: "[INFO]",
        }
        return icons.get(severity, "[?]")


# Export function for CLI
def export_findings(
    report: Report,
    format: str,
    output_path: str | None = None,
) -> str | dict:
    """
    Export report findings to specified format.

    Args:
        report: The assessment report
        format: Export format (hackerone, bugcrowd, sarif, github, markdown)
        output_path: Optional path to write output

    Returns:
        Formatted output (string or dict depending on format)
    """
    exporter = BugBountyExporter()

    if format == "hackerone":
        # Export each finding as separate HackerOne report
        outputs = []
        for finding in report.findings:
            outputs.append(exporter.export_hackerone(finding))
        result = "\n\n---\n\n".join(outputs)

    elif format == "bugcrowd":
        result = {
            "submissions": [
                exporter.export_bugcrowd(f) for f in report.findings
            ],
        }

    elif format == "sarif":
        result = exporter.export_sarif(report)

    elif format == "github":
        result = {
            "advisories": [
                exporter.export_github_advisory(f) for f in report.findings
            ],
        }

    elif format == "markdown":
        result = exporter.export_markdown_summary(report)

    else:
        raise ValueError(f"Unknown export format: {format}")

    # Write to file if path provided
    if output_path:
        from pathlib import Path
        path = Path(output_path)

        if isinstance(result, dict):
            path.write_text(json.dumps(result, indent=2))
        else:
            path.write_text(result)

        logger.info("report_exported", format=format, path=output_path)

    return result
